\input{arbeit-vorlage-praeambel.tex} % Importiere die Einstellungen aus der Präambel
% hier beginnt der eigentliche Inhalt

\author{Lydia Buntrock}
\title{master thesis}
\date{August 2017}

\begin{document}
  % Titelseite
  \begin{titlepage}
    \pagestyle{empty}
  	
    	\vspace{20mm}
    	\begin{Large}
    	    \textbf{Origins and losses of parasitism}\\
          an analysis of the phylogenetic tree of life with a parsimony-like algorithm\\
    	\end{Large}

  	\clearpage
  \end{titlepage}

%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
%--------------------------------------------------------------------------------------------------- 
\chapter*{Abstract}

\tableofcontents
\clearpage

%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
%--------------------------------------------------------------------------------------------------- 
\chapter{Introduction}
  This paper is about the further development of parsimony algorithms for non-binary trees, applied 
  to the currently largest phylogeny synthesis tree of Open Tree Of Life, with the application to 
  the ancestral state reconstruction of parasitism. \\
  Researchers of the phylogenies have been dealt with the ancenstral state reconstruction in the 
  60s. The first methods were only brute force \todo{Quelle, siehe Fitch: Camin and Sokal 1965}. 
  Next came a set of parsimony algorithms such as: Fitch-parsimony \cite{Fitch1971}, 
  Wagner-parsimony \cite{Swofford1987} ... \todo{weitere?}. \\
  With more and more data, there is now the possibility to use more information to calculate the 
  probabilities of the ancestral states. In addition to the states of the leaves, algorithms could 
  also use branch lengths. The likelihood based algorithms came more in interest. \\
  Our focus came with another 'data extension'. We wanted to work with the biggest phylogenetic tree 
  that exists at this moment, which goes over all observed species. For most \todo{most?} species 
  there is no 
  phylogeny, but only a taxonomic classification. So the biggest 'phylogenetic tree' is a synthesis 
  of phylogenetic trees filled with a taxonomic tree given by Open Tree of Life \cite{Hinchliff2015}.
  This tree is not binary and therefore the developed algorithms are not directly applicable. \\
  In this work, we have looked at the algorithms that are generally suited to our data, to develop 
  them further for the not binary case, and finally to compare their usability with our sythesis 
  tree. \\
  We have decided to consider only parsimony algorithms since we have no information on branch 
  lengths and no other additional information like different transition probabilities of our states.

%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
%--------------------------------------------------------------------------------------------------- 
\chapter{Methods}
  
  This work consist of two aspects. One is the application of the algorithm to our question

  Diese Arbeit besteht aus zwei Fragestellungen
  gute Algorithmen zu finden und sie auf unser Anwendungsbeispiel anzuwenden.

  Zur Bewertung der gefundenen / entwickelten algorithmen haben wir eine Simulation ausgeführt.

  Auf der Anderen Seite haben wir unser reales Problem aufgestellt, für die Algorithmen vorbereitet und 
  diese angewendet.
  

  Metadata -> Simulation ->  real Data

  %---------------------------------------------------------------------------------------------------
  %---------------------------------------------------------------------------------------------------
  \section{Metadata analysis}
    Properties of real Data - Metadata analysis

    There are some Parameters to find out or notice:
    \begin{itemize}
      \item transition probabilities of tags
      \item multifurcation
      \item nr of parasites to free-living
      \item nr of unknown nodes 
    \end{itemize}

  %---------------------------------------------------------------------------------------------------
  %---------------------------------------------------------------------------------------------------
  \section{Simulation}
    \begin{itemize}
      \item build random binary trees, tag these (parameters: parasites vs free-living, 
        beta-distribution)
      \item run fitch-parsimony, wagner-parsimony, our parsimony like algorithm
      \item build not binary tree (poisson distribution?)
      \item run new algorithms
      \item compare trees (distances)
    \end{itemize}

    \begin{enumerate}
      \item build random binary trees
      \item tag tree
      \item multifurcate tree
      \item run maximum parsimony algorithms
      \begin{itemize}
        \item Fitch
        \item Sankoff (Castor package)
        \item my algorithm
      \end{itemize}
      \item Evaluation
    \end{enumerate}

    %---------------------------------------------------------------------------------------------------
    \subsection{random binary tree}
      To get a random binary tree, I used the Phylo package from biopython. They offer a randomized
        function which returns a BaseTree \footnote{
          https://github.com/biopython/biopython/blob/master/Bio/Phylo/BaseTree.py
        }:
      \begin{lstlisting}
        from Bio import Phylo
        Phylo.BaseTree.Tree.randomized(number_leafnodes)
      \end{lstlisting}
      From the BaseTree class:
      \begin{lstlisting}
        def randomized(cls, taxa, branch_length=1.0, 
              branch_stdev=None):
        """Create a randomized bifurcating tree given a list
              of taxa.
          :param taxa: Either an integer specifying the number
              of taxa to create (automatically named taxon#), 
              or an iterable of taxon names, as strings.
          :returns: a tree of the same type as this class.
        """
      \end{lstlisting}
      \todo{Zitat von BaseTree und buildTree.py}

    %---------------------------------------------------------------------------------------------------
    \subsection{tag tree}
      At this point we want one fully tagged tree, and one less tagged tree which looks like our real 
        data.\\
      Let's say the first specie (the root node) was free-living (start with a parasite without a host 
        makes no sence). For every transition from a node to his child, we take a random number from
        the father distribution. We decided that from the biological perspective a beta distribution
        reflects our transition probabilities best (see Figure 2.1 \todo{ref einfügen}). \\
        For example when our father node was free-living, then we take from the free-living beta
        distribution. Is the number under the threshold for beeing parasite, we get a change and tag
        the current node as parasite. Otherwise we tag it as free-living. \\
        With this procedure we traverse through the tree from the root to every leave node. A part of
        this code you see here:
      \begin{lstlisting}
        from numpy import random
        if father_tag == 0:
          # freeliving_distribution:
          new_random = random.beta(a=A_FL, b=B_FL)
        else:
          # parasite_distribution:
          new_random = random.beta(a=A_P, b=B_P)
        tag = 0         # -> FL
        if new_random < percentage_parasites:
          tag = 1       # -> P
      \end{lstlisting}
      \begin{figure}
        \caption{60\% Free-living - 40\% Parasites}
        \centering
          \includegraphics[width=0.5\textwidth]{Figures/40-60.png}
      \end{figure}
      \todo{Bessere Beschriftung, Plot neu erstellen! U.a. mit threshold}
      We save each tag with the associated node ID in a nodelist, where we can save all information
        about our nodes, we want. \\
      The real tree has much less information, we have only information from some current species 
        (leave nodes) and \todo{and probably negligible internal nodes}. \\
      To simulate our real tree we save for every node an empty placeholde except for some leave nodes.
      There we save the tags again. The amount of these unknown information is one parameter, which we
      got from our real tree. Or which we can change to \todo{...}
      \TODO{Was hiervon gehört ind Methoden, was schon in Implementierung oder ganz woanders hin?}

    %---------------------------------------------------------------------------------------------------
    \subsection{multifurcate tree}
      Another parameter is the nature and strength of the multifunction of the tree, since we do not 
        have a binary tree in the real case. After several measurements and analyzes, which we explain 
        in \todo{section/chapter x}, we decided to use a $1 over x$ distribution, where x is the depth 
        of a node. This means, how deaper we are, how less information we have. \\
      We traverse through the tree and pick a random number between 0 and 1. If random number is smaller 
        as our limit ($1 over x$), than we forget the node and hang every child to the father node of 
        the current node.
      \todo{then / than}
      \begin{lstlisting}
        from numpy import random
        from utilities import Helpers

        def get_non_binary_tree(subtree, nodelist):
          i = 0
          while i != len(subtree.clades):
            if subtree.clades[i].is_terminal():             # is leave node?
              i += 1
            else:
              element = Helpers.find_element_in_nodelist(subtree.clades[i].name, nodelist)
              limit = get_limit(element[1])
              new_random = random.uniform()                 # choose if we want to delete ourselve
              if new_random < limit:                        # or new_random < 0.9:
                subtree.clades += subtree.clades[i].clades  # add children
                del subtree.clades[i]                       # delete internal node
              else:                                         # if we don't deleted ourselve go on with children
                get_non_binary_tree(subtree.clades[i], nodelist)  # otherwise the children are in the current clade array
                i += 1
          return

          def get_limit(depth):
            limit = 1 - 1 / ((depth + 3) / 4)
            if limit < 0.1:
              limit = 0.1
            return limit
      \end{lstlisting}
      % # current clades: clade_1 clade_2 ... clade_i-1 clade_i ... clade:_n
      % # add children of clade_i, delete clade_i
      % # new clades:clade_1 clade_2 ... clade_i-1 child_clade_1 ... child_clade_m ... clade:_n
      % # child_clade_1 is new clade i
      Wir lassen das Limit nicht beliebig klein werden, sondern beschränken es auf 0.1.

    %---------------------------------------------------------------------------------------------------
    \subsection{maximum parsimony algorithms}
      \subsubsection{Fitch maximum parsimony}
        Described from [COO98] - implemented for multifurcating trees
        \begin{figure}
          \caption{bla}
          \centering
            \includegraphics[width=0.5\textwidth]{Figures/Fitch1.png}
        \end{figure}

      \subsubsection{Sankoff}
      \subsubsection{my Algorithm}

  %---------------------------------------------------------------------------------------------------
  %---------------------------------------------------------------------------------------------------
  \section{real data analysis}
    \begin{itemize}
      \item Import tree
      \item Import interactions
      \item run castor algorithm / and others?
      \item interprete results (leave one out)
    \end{itemize}

  %---------------------------------------------------------------------------------------------------
  %---------------------------------------------------------------------------------------------------
  \section{Implementation}

%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
\chapter{Results}

%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
\chapter{Discussion}
  Wie gut ist der randomisiert erstellte Baum? \\
  Wie gut kommt unsere Simulation an die echte Datenlage heran. \\
  Fehlerqoute der Daten an sich? \\
  Wie gut ist unsere Datenlage? 3 mio knoten, 1.8 named species (leaf nodes), 200.000 leaf nodes mit 
  Information. \\
  Simulation von subtrees \\
  Welche Teile des Baumes sind gut, an welchen muss noch viel geforscht werden. \\
  Wieviele Origins haben wir gefunden, was bedeutet diese Zahl? \\
  
  Parameter der Simulation:
  \begin{itemize}
    \item Wie ist die Verteilung der vergessenen internen Knoten? Zum Wurzelknoten hin mehr vergessen?
    \item Wie sehen die übergangswahrscheinlichkeiten aus von P->FL und andersherum?
    \item Verteilung Parasiten zu Freilebend zu keine Information
  \end{itemize}


  Selecting of the 'right'  / best Distribution
  
%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------
\bibliography{bibliographie}
\bibliographystyle{alphadin}


\end{document}
